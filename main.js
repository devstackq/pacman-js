const mapGame = [
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  4,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  4,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  0,
  0,
  0,
  0,
  1,
  1,
  0,
  0,
  0,
  0,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  9,
  1,
  1,
  9,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  3,
  3,
  3,
  3,
  3,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  9,
  1,
  1,
  9,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  1,
  0,
  1,
  1,
  9,
  9,
  9,
  9,
  9,
  9,
  9,
  9,
  9,
  9,
  1,
  1,
  0,
  1,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  1,
  0,
  1,
  1,
  9,
  1,
  1,
  1,
  6,
  6,
  1,
  1,
  1,
  9,
  1,
  1,
  0,
  1,
  3,
  3,
  3,
  3,
  3,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  9,
  1,
  1,
  9,
  9,
  9,
  9,
  1,
  1,
  9,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  8,
  9,
  9,
  9,
  9,
  9,
  9,
  0,
  9,
  9,
  9,
  1,
  1,
  2,
  2,
  2,
  2,
  1,
  1,
  9,
  9,
  9,
  0,
  9,
  9,
  9,
  9,
  9,
  9,
  8,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  9,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  9,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  3,
  3,
  3,
  3,
  3,
  1,
  0,
  1,
  1,
  9,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  9,
  1,
  1,
  0,
  1,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  1,
  0,
  1,
  1,
  9,
  9,
  9,
  9,
  9,
  9,
  9,
  9,
  9,
  9,
  1,
  1,
  0,
  1,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  1,
  0,
  1,
  1,
  9,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  9,
  1,
  1,
  0,
  1,
  3,
  3,
  3,
  3,
  3,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  9,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  9,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  4,
  0,
  0,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  9,
  9,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  0,
  0,
  4,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  0,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  0,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  0,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  0,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  0,
  0,
  0,
  0,
  1,
  1,
  0,
  0,
  0,
  0,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
];

//1 wall, 0 coin, 4 cookie, 8 teleport, 3 -empty, 9 freepath

//for work - another thread calculate hard func
const worker = new SharedWorker("worker.js", {
  type: "module",
  name: "sharedWorker",
});

//keys state, l/r/u/d
const keys = {
  ArrowLeft: false,
  ArrowRight: false,
  ArrowUp: false,
  ArrowDown: false,
  restart: false,
};

let rafId = 0;

//manage dom elems - coin opacity
const mapItemsInDom = [];
//for dumping props object, add pacamn & ghost Dom objects
const obj = {};
//clear interval - when temeout 10sec
let interval;
// let killTimer;
let arrGhosts = [];

const props = {
  x: "", // for grid row - first render items in Dom - set grid style
  y: "",
  h: 31, // height borad, count Y
  size: 28,
  inPlay: false, // play state
  time: {
    sec: 0,
    min: 0,
  },
};

//pacman object
const player = {
  posX: 425, //def posX - transform translate
  posY: 695,
  score: 0,
  life: 5,
  indexMap: 658, // index for work []MapGame
  cool: 0,
  speed: 5, //for Raf, 16.7 * 5 = 83ms
  canKill: false, // coin eate
  time: {
    sec: 0,
    min: 0,
  },
  countCoin: 0,
  rafId: 0, // start, stop raf
  pause: false,
  killTime: 10000,
  transX: "", // change mouse pos
  currentPos: 0,
  nick: "pacman",
  showMenu: false,
  gameState: "",
  direct: "",
};

//ghost objects - for manipualte game

let unitsMT = {
  pinkGhost: {
    posX: 360,
    posY: 420,
    basePos: 404,
    direct: "right",
  },
  orangeGhost: {
    posX: 390,
    posY: 420,
    basePos: 405,
  },
  redGhost: {
    posX: 420,
    posY: 420,
    basePos: 406,
  },
  cyanGhost: {
    posX: 450,
    posY: 420,
    basePos: 407,
    direct: "up",
  },
  pacman: {
    posX: 450,
    posY: 420,
    basePos: 407,
    transX: "",
    indexMap: 0,
    life: 5,
    score: 0,
    countCoin: 0,
    canKill: false,
    gameState: "",
    showMenu: false,
    pause: false,
  },
  cool: 0,
};

//dom onladed -> get grid elem, -> append - block, then manipulate this dom object, etc
document.URL.includes("play.html")
  ? document.addEventListener("DOMContentLoaded", () => {
      //save cache dom in nodes - addres in Ram - > then change by pointer
      props.grid = document.querySelector("div.grid");
      props.modal = document.querySelector("div.modal");
      props.notify = document.querySelector("div.notify");
      props.scoreBoard = document.querySelector("div.scoreBoard");
      obj.pacman = document.querySelector("div.pacman");
      obj.pacman_mouth = document.querySelector("div.pacman_mouth");
      //set default pos in Dom
      obj.pacman.style.transform = `translate(425px, 695px,0)`;
      obj.redGhost = document.querySelector("div.red");

      obj.orangeGhost = document.querySelector("div.orange");
      obj.pinkGhost = document.querySelector("div.pink");
      obj.cyanGhost = document.querySelector("div.cyan");
      createBoard();
    })
  : null;

document.addEventListener("keyup", (e) => {
  if (e.code in keys) {
    keys[e.code] = false;
  }
  if (unitsMT.pacman.pause) {
    window.cancelAnimationFrame(rafId);
    clearInterval(interval);
  }
});

const startTime = () => {
  interval = setInterval(() => {
    props.time.sec += 1;
    props.time.sec === 60 ? ((props.time.sec = 0), (props.time.min += 1)) : 0;
  }, 1000);
};

document.addEventListener("keydown", (e) => {
  if (e.code in keys) {
    keys[e.code] = true;
  }

  if (
    e.code === "ArrowLeft" ||
    e.code === "ArrowRight" ||
    e.code === "ArrowDown" ||
    e.code === "ArrowUp"
  ) {
    //cahnge bg pacman & ghost if canKill
    if (unitsMT.pacman.canKill) {
      obj.pacman.style.background = "red";
      obj.redGhost.style.opacity = ".4";
      obj.orangeGhost.style.opacity = ".4";
      obj.pinkGhost.style.opacity = ".4";
      obj.cyanGhost.style.opacity = ".4";
    } else {
      obj.pacman.style.background = "yellow";
      obj.redGhost.style.opacity = "1";
      obj.orangeGhost.style.opacity = "1";
      obj.pinkGhost.style.opacity = "1";
      obj.cyanGhost.style.opacity = "1";
    }
    if (!props.inPlay) {
      props.notify.style.display = "none";
      props.inPlay = true;
      rafId = requestAnimationFrame(step);
      //time
      startTime();
    }
  }
  //esc || showModal keydown - show modal page
  //|| unitsMT.pacman.showMenu !== false
  if (e.code === "Escape") {
    endGame("escape");
  }
});
//transform translate each item - change posit 0 in Dom
const render = (...args) => {
  args.forEach((el, i) => {
    obj[el.nick].style.transform = `translate(${el.posX}px, ${el.posY}px)`;
  });
};

const restart = () => {
  // window.cancelAnimationFrame(rafId);
  // window.location.reload();
  keys.restart = true;
  //set default values
  props.inPlay = false;
  unitsMT.pacman.pause = false;
  props.time.min = 0;
  props.time.sec = 0;

  //show notify
  props.notify.style.display = "block";
  //update time
  clearInterval(interval);
  props.modal.children[0].textContent = ` Your Score ${unitsMT.pacman.score} Lives ${unitsMT.pacman.life}  Time: ${props.time.min}m:${props.time.sec} s`;

  //return opacity coin elem
  for (let i = 0; i <= 868; i++) {
    if (props.grid.children[i].children[0] !== undefined) {
      if (
        props.grid.children[i].children[0].className === "coin" ||
        props.grid.children[i].children[0].className === "cookie"
      ) {
        props.grid.children[i].children[0].style.opacity = 1;
      }
    }
  }
  props.modal.style.display = "none";
};

const endGame = (type) => {
  //show notify - you win
  props.modal.style.display = "flex";
  unitsMT.pacman.pause = true;

  // console.log("res", unitsMT.pacman.score, unitsMT.pacman.gameState);
  if (type === "escape") {
    //show with Continue
  }
  if (type === "win") {
  }
  if (type === "lose") {
  }

  if (unitsMT.pacman.showMenu) {
    let msg = "";
    if (unitsMT.pacman.gameState === "win") {
      msg = "Congrats, Yeap! You Win!";
    } else {
      msg = "Game over..";
    }
    // props.modal.children[0].style.display = "block";
    props.modal.children[0].textContent = `${msg} Your Score ${unitsMT.pacman.score} Lives ${unitsMT.pacman.life}  Time: ${props.time.min}m:${props.time.sec} s`;
  } else {
    if (unitsMT.pacman.life > 0) {
      // continue
      props.modal.children[1].style.display = "block";
    }
  }

  //continue btn
  props.modal.children[1].onclick = (e) => {
    rafId = requestAnimationFrame(step);
    unitsMT.pacman.pause = false;
    props.inPlay = true;
    props.modal.style.display = "none";
    startTime();
  };
  //restart btn
  props.modal.children[2].onclick = (e) => {
    //set def value
    props.modal.style.display = "none";
    unitsMT.pacman.pause = false;
    props.inPlay = false;
    restart();
  };
  props.modal.children[3].onclick = (e) => {
    window.location.href = "http://localhost:5500/";
  };
};

//TODO
//check fps google
// add audio,
//add keyframe - when pacman death
//ref class component

//start project -> History || scorebaord
//add my sound history  & text -> button - skip button
//add instruction modal window  - how to play game
//menu -> toggle - from - key - not use Mouse
// check data - countCoin ==244, - show Modal; life ==0 -> show modal gameOver - fix

// window.onload = focus();
const step = () => {
  if (props.inPlay) {
    //worker ?
    unitsMT.cool--;
    if (unitsMT.cool < 0) {
      // ghosts: JSON.stringify(ghosts),
      worker.port.postMessage({ key: keys }); //key state - pacman

      //not use forEach
      worker.port.onmessage = (e) => {
        unitsMT.cyanGhost.posX = e.data.cyanGhost.posX;
        unitsMT.cyanGhost.posY = e.data.cyanGhost.posY;

        unitsMT.redGhost.posX = e.data.redGhost.posX;
        unitsMT.redGhost.posY = e.data.redGhost.posY;

        unitsMT.orangeGhost.posX = e.data.orangeGhost.posX;
        unitsMT.orangeGhost.posY = e.data.orangeGhost.posY;

        unitsMT.pinkGhost.posX = e.data.pinkGhost.posX;
        unitsMT.pinkGhost.posY = e.data.pinkGhost.posY;
        //set updated data from bg thread
        unitsMT.pacman.posX = e.data.pacman.posX;
        unitsMT.pacman.posY = e.data.pacman.posY;
        unitsMT.pacman.indexMap = e.data.pacman.indexMap;
        unitsMT.pacman.score = e.data.pacman.score;
        unitsMT.pacman.life = e.data.pacman.life;
        unitsMT.pacman.countCoin = e.data.pacman.countCoin;
        unitsMT.pacman.canKill = e.data.pacman.canKill;
        keys.restart = e.data.pacman.restart;
      };

      //get index - by formula, posX, posY - index for mapGame
      // formula = y / 30 * 28 + x / 30

      //if changed pacman index, eqaul 4 || 0, add score, change - currentPos = 0, -> currPos = 9
      if (mapGame[unitsMT.pacman.indexMap] !== 1) {
        if (
          unitsMT.pacman.indexMap !== 391 &&
          unitsMT.pacman.indexMap !== 420 &&
          unitsMT.pacman.indexMap !== 350 &&
          unitsMT.pacman.indexMap !== 349
        ) {
          //change opacity - coin
          mapItemsInDom[unitsMT.pacman.indexMap].children[0].style.opacity = 0;
        }
        //change mouth - pacman
        obj.pacman_mouth.style.transform = unitsMT.pacman.transX;
      }

      if (unitsMT.pacman.life > 0) {
        if (unitsMT.pacman.countCoin === 4) {
          unitsMT.pacman.showMenu = true;
          unitsMT.pacman.gameState = "win";
          endGame("win");
        }
      } else {
        unitsMT.pacman.showMenu = true;
        unitsMT.pacman.gameState = "lose";
        endGame("lose");
      }

      //not use loop
      obj.pacman.style.transform = `translate(${unitsMT.pacman.posX}px, ${unitsMT.pacman.posY}px)`;

      obj.redGhost.style.transform = `translate(${unitsMT.redGhost.posX}px, ${unitsMT.redGhost.posY}px)`;
      obj.orangeGhost.style.transform = `translate(${unitsMT.orangeGhost.posX}px, ${unitsMT.orangeGhost.posY}px)`;
      obj.cyanGhost.style.transform = `translate(${unitsMT.cyanGhost.posX}px, ${unitsMT.cyanGhost.posY}px)`;
      obj.pinkGhost.style.transform = `translate(${unitsMT.pinkGhost.posX}px, ${unitsMT.pinkGhost.posY}px)`;

      //updated value - render scoreboard
      props.scoreBoard.children[0].textContent = `Score ${unitsMT.pacman.score} Lives ${unitsMT.pacman.life}  Time: ${props.time.min}m:${props.time.sec}s`;
      //cooldwon, 5 * 16.7 -> reaction each 83ms
      unitsMT.cool = 6;
    }
    rafId = requestAnimationFrame(step);
    if (unitsMT.pacman.pause) {
      window.cancelAnimationFrame(rafId);
    }
  }
};

const createBoard = () => {
  //create each block -> get data from mapGame array
  mapGame.forEach((el, idx) => {
    createBlock(el);
  });

  // get static elems -> add in Obejct, then add array - tags, change values -> render new value
  for (let i = 0; i < props.size; i++) {
    props.x += 30 + "px "; //cell grid height, width count - for grid
  }
  // 31 count height field Map
  for (let i = 0; i < props.h; i++) {
    props.y += 30 + "px "; //cell grid rows count, 31px
  }
  //set grid rows, columns, size - count
  props.grid.style.gridTemplateColumns = props.x;
  props.grid.style.gridTemplateRows = props.y;
  //board localy dom, props.grid -> in DOm browser inserted
};
const createBlock = (type) => {
  let div = document.createElement("div");
  div.classList.add("box");
  //create new div -> add class, append object - props.grid
  if (type === 0) {
    const coin = document.createElement("div");
    coin.classList.add("coin");
    div.append(coin);
  } else if (type === 1) {
    let wall = document.createElement("div");
    wall.classList.add("wall");
    div.append(wall);
  } else if (type === 4) {
    let cookie = document.createElement("div");
    cookie.classList.add("cookie");
    div.append(cookie);
  } else if (type === 6) {
    let door = document.createElement("div");
    door.classList.add("doorEnemy");
    div.append(door);
  } else if (type === 8) {
    let teleport = document.createElement("div");
    teleport.classList.add("teleport");
    div.append(teleport);
  } else if (type === 9) {
    let free = document.createElement("div");
    free.classList.add("free");
    div.append(free);
  }
  div.type = type;
  mapItemsInDom.push(div);
  props.grid.append(div);
};
