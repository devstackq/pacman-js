let mapGame = [
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  4,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  4,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  0,
  0,
  0,
  0,
  1,
  1,
  0,
  0,
  0,
  0,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  9,
  1,
  1,
  9,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  3,
  3,
  3,
  3,
  3,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  9,
  1,
  1,
  9,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  1,
  0,
  1,
  1,
  9,
  9,
  9,
  9,
  9,
  9,
  9,
  9,
  9,
  9,
  1,
  1,
  0,
  1,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  1,
  0,
  1,
  1,
  9,
  1,
  1,
  1,
  6,
  6,
  1,
  1,
  1,
  9,
  1,
  1,
  0,
  1,
  3,
  3,
  3,
  3,
  3,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  9,
  1,
  1,
  9,
  9,
  9,
  9,
  1,
  1,
  9,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  8,
  9,
  9,
  9,
  9,
  9,
  9,
  0,
  9,
  9,
  9,
  1,
  1,
  2,
  2,
  2,
  2,
  1,
  1,
  9,
  9,
  9,
  0,
  9,
  9,
  9,
  9,
  9,
  9,
  8,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  9,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  9,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  3,
  3,
  3,
  3,
  3,
  1,
  0,
  1,
  1,
  9,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  9,
  1,
  1,
  0,
  1,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  1,
  0,
  1,
  1,
  9,
  9,
  9,
  9,
  9,
  9,
  9,
  9,
  9,
  9,
  1,
  1,
  0,
  1,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  1,
  0,
  1,
  1,
  9,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  9,
  1,
  1,
  0,
  1,
  3,
  3,
  3,
  3,
  3,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  9,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  9,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  4,
  0,
  0,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  9,
  9,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  0,
  0,
  4,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  0,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  0,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  0,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  0,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  0,
  0,
  0,
  0,
  1,
  1,
  0,
  0,
  0,
  0,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
];

const worker = new SharedWorker("worker.js", {
  type: "module",
  name: "sharedWorker",
});

//keys state
const keys = {
  ArrowLeft: false,
  ArrowRight: false,
  ArrowUp: false,
  ArrowDown: false,
};
//manage dom elems - coin opacity
const temp = [];

const props = {
  x: "", // for grid  row - render style
  y: "",
  h: 31, // height borad, count Y
  size: 28,
  inPlay: false,
};
//test obj, for dumping props object
const obj = {};
let interval;
let killTimer;

const player = {
  posX: 425, //def posX - transform translate
  posY: 695,
  score: 0,
  life: 5,
  indexMap: 658,
  cool: 0,
  speed: 5,
  canKill: false,
  time: {
    sec: 0,
    min: 0,
  },
  countCoin: 0,
  rafId: 0,
  pause: false,
  killTime: 10000,
  transX: "",
  currentPos: 0,
};

const ghosts = {
  pinkGhost: {
    name: "Pinkī",
    posX: 360,
    posY: 420,
    basePos: 404,
    direct: "right",
    color: "pink",
  },
  orangeGhost: {
    name: "Guzuta",
    posX: 390,
    posY: 420,
    basePos: 405,
    direct: "up",
    color: "orange",
  },
  redGhost: {
    name: "Akabei",
    posX: 420,
    posY: 420,
    basePos: 406,
    direct: "up",
    color: "red",
  },
  cyanGhost: {
    name: "Aosuke",
    posX: 450,
    posY: 420,
    basePos: 407,
    direct: "left",
    color: "cyan",
  },
  cool: 0,
};

//dom onladed -> get grid elem, -> append - block, then manipulate this dom object, etc
document.URL.includes("play.html")
  ? document.addEventListener("DOMContentLoaded", () => {
      //chache dom in nodes - addres in Ram
      props.grid = document.querySelector("div.grid");
      obj.pacman = document.querySelector("div.pacman");
      obj.pacman_mouth = document.querySelector("div.pacman_mouth");
      props.modal = document.querySelector("div.modal");
      props.notify = document.querySelector("div.notify");
      props.scoreBoard = document.querySelector("div.scoreBoard");
      //set default pos in Dom
      // obj.pacman.style.display = "block";
      obj.pacman.style.transform = `translate3d(425px, 695px,0)`;
      // obj.pacman.style.transition = '0.1s ease'
      obj.redGhost = document.querySelector("div.red");
      obj.orangeGhost = document.querySelector("div.orange");
      obj.pinkGhost = document.querySelector("div.pink");
      obj.cyanGhost = document.querySelector("div.cyan");

      createBoard();
      console.log(props.grid.children.length, temp.length);
    })
  : null;

document.addEventListener("keyup", (e) => {
  if (e.code in keys) {
    keys[e.code] = false;
    player;
  }
});

const startTime = () => {
  interval = setInterval(() => {
    player.time.sec += 1;
    player.time.sec === 60
      ? ((player.time.sec = 0), (player.time.min += 1))
      : 0;
  }, 1000);
};

document.addEventListener("keydown", (e) => {
  if (e.code in keys) {
    keys[e.code] = true;
  }
  // console.log(mapGame[player.indexMap - 1], player.indexMap)
  if (!props.inPlay) {
    props.notify.style.display = "none";
    props.inPlay = true;
    player.rafId = requestAnimationFrame(step);
    //time
    startTime();
  }

  //esc - show modal page
  if (e.code === "Escape") {
    props.modal.style.display = "flex";
    // continue
    props.modal.children[1].style.display = "block";
    player.pause = true;
    window.cancelAnimationFrame(player.rafId);
    clearInterval(interval);
    //continue btn
    props.modal.children[1].onclick = (e) => {
      player.play = requestAnimationFrame(step);
      player.pause = false;
      props.inPlay = true;
      props.modal.style.display = "none";
      startTime();
    };
    //restart btn
    props.modal.children[2].onclick = (e) => {
      //set def value
      props.modal.style.display = "none";
      restart("restart");
    };
    props.modal.children[3].onclick = (e) => {
      window.location.href = "http://localhost:8000/";
    };
  }
});

const restart = (type) => {
  //set default values
  props.inPlay = false;
  ghosts.orangeGhost.basePos = 404;
  ghosts.pinkGhost.basePos = 405;
  ghosts.redGhost.basePos = 406;
  ghosts.cyanGhost.basePos = 407;
  ghosts.redGhost.posX = 420;
  ghosts.redGhost.posY = 420;

  player.posX = 425;
  player.posY = 695;

  player.pause = false;

  player.countCoin = 0;
  player.time.min = 0;
  player.time.sec = 0;

  if (type == "tryAgain") {
    player.life == 0 ? (player.score = 0) : player.score;
    ghosts.cool = 0;
  }

  if (type == "restart") {
    player.cool = 0;
    player.life = 5;
    player.score = 0;
  }

  props.notify.style.display = "block";
  //update time
  clearInterval(interval);
  props.scoreBoard.children[0].textContent = `Score ${player.score} Lives ${player.life}  Time: ${player.time.min}m:${player.time.sec}s`;

  //return opacity coin elem
  for (let i = 0; i <= 868; i++) {
    if (props.grid.children[i].children[0] !== undefined) {
      if (
        props.grid.children[i].children[0].className === "coin" ||
        props.grid.children[i].children[0].className === "cookie"
      ) {
        props.grid.children[i].children[0].style.opacity = 1;
      }
    }
  }
  obj.pacman.style.transform = `translate3d(${player.posX}px, ${player.posY}px, 0px)`;
  //set pacman def pos
  //loop each ghost set default pos
  obj.redGhost.style.transform = `translate3d(${ghosts.redGhost.posX}px, ${ghosts.redGhost.posY}px, 0px)`;

  player.rafId = requestAnimationFrame(step);
};

const endGame = () => {
  props.modal.children[0].textContent = `Congrats, Yeap!  Your Score ${player.score} Lives ${player.life}  Time: ${player.time.min}m:${player.time.sec} s`;
  props.modal.style.display = "flex";
  player.pause = true;

  props.modal.children[0].style.display = "block";
  props.modal.children[2].style.display = "block";
  props.modal.children[3].style.display = "block";

  props.modal.children[2].onclick = (e) => {
    restart();
  };
  //main menu
  props.modal.children[3].onclick = (e) => {
    e.preventDefault();
    window.location.href = "http://localhost:8000/";
  };
};

const killGhost = (time) => {
  if (player.canKill) {
    obj.pacman.style.backgroundColor = "red";
    killTimer = setTimeout(() => {
      player.canKill = false;
      obj.pacman.style.backgroundColor = "#fff";
      // manageGhosts("goAway"); //set default color ghost
    }, time); //10sec
  }
};

//audit hint
// 6speed - norm, without trans, 15-20s
// зажимать move key,
// на стену не идти все пути гладко проходить
// wiil cahnge without will change - no differ
// without transition
// no use teleport, and coin
// gc - off - perfomance tools

//chrome - work - will cahnge
// chrome - audiit- show realtime fps - beacuse layer Work

//TODO
// each ghost & pacman - use webworker,
//add sounds
//loop ghsot check || condition ? || func - ghost == pacman, change bgcolor ghosts, !canKill -> goHome Pacman, else goHomeGhost

// layout, paint ngc,
//audit webpage lighthouse
//add kyeframes - if pacman death
//optimize code - SOLID
//DRY, SR
//delete no need comment
//check chrome fps, and ,ozila laptop

// -> when endGame -> & life > 0 -> restore - coin, & score  fix
//case currDir = left, if nextPost ==1, and downDirect nextPos == 1, gotoUp
// send data [ghost1, ghost2, ghost3..., pacman] || create new Worker ?
//when restart game , life > 0, -> - last coin not restore ? fix
//optimize worker.js file

todo ghost == pacman,
//add keyframe - when pacman deat
// add audio

const goHomeGhost = (ghost) => {
  //what ghost ? - set def positi
  ghost.basePos = 405;
  //render
};

const goHome = () => {
  player.life--;
  player.posX = 425;
  player.posY = 695;
  player.indexMap = 658;
  //render
  obj.pacman.style.transform = `translate3d(${player.posX}px, ${player.posY}px, 0)`;
};

const step = () => {
  if (props.inPlay) {
    ghosts.cool--;
    if (ghosts.cool < 0) {
      //send data - worker
      worker.port.postMessage([
        { dir: ghosts.cyanGhost.direct, ghost: "cyanGhost" },
        { dir: ghosts.redGhost.direct, ghost: "redGhost", type: "perimeter" },
        {
          dir: ghosts.orangeGhost.direct,
          ghost: "orangeGhost",
          type: "perimeter",
        },
        { dir: ghosts.pinkGhost.direct, ghost: "pinkGhost", type: "square" },
      ]);
      //get calculated data
      worker.port.onmessage = (e) => {
        //loop ?
        ghosts.cyanGhost.direct = e.data[0][0];
        ghosts.cyanGhost.basePos = e.data[0][1];
        ghosts.cyanGhost.posX = e.data[0][2];
        ghosts.cyanGhost.posY = e.data[0][3];

        ghosts.redGhost.direct = e.data[1][0];
        ghosts.redGhost.basePos = e.data[1][1];
        ghosts.redGhost.posX = e.data[1][2];
        ghosts.redGhost.posY = e.data[1][3];

        ghosts.orangeGhost.direct = e.data[2][0];
        ghosts.orangeGhost.basePos = e.data[2][1];
        ghosts.orangeGhost.posX = e.data[2][2];
        ghosts.orangeGhost.posY = e.data[2][3];

        ghosts.pinkGhost.direct = e.data[3][0];
        ghosts.pinkGhost.basePos = e.data[3][1];
        ghosts.pinkGhost.posX = e.data[3][2];
        ghosts.pinkGhost.posY = e.data[3][3];
      };
      //render each ghost
      obj.cyanGhost.style.transform = `translate3d(${ghosts.cyanGhost.posX}px, ${ghosts.cyanGhost.posY}px, 0px)`;
      obj.redGhost.style.transform = `translate3d(${ghosts.redGhost.posX}px, ${ghosts.redGhost.posY}px, 0px)`;
      obj.orangeGhost.style.transform = `translate3d(${ghosts.orangeGhost.posX}px, ${ghosts.orangeGhost.posY}px, 0px)`;
      obj.pinkGhost.style.transform = `translate3d(${ghosts.pinkGhost.posX}px, ${ghosts.pinkGhost.posY}px, 0px)`;
      //speed
      ghosts.cool = 6;
    }

    player.cool--;

    if (player.cool < 0) {
      player.indexMap = Math.floor(
        ((player.posY - 5) / 30) * 28 + (player.posX - 5) / 30
      );
      // formula = y / 30 * 28 + x / 30, 690/30=23*28 644 + 420/30 = 644 + 14 = 658+1 mapGame[659]
      if (keys.ArrowLeft) {
        // player.indexMap -= 1;
        if (mapGame[player.indexMap - 1] !== 1) {
          player.posX -= 30;
          player.indexMap -= 1;
          player.transX = "translateX(0%)";
          //replace classs -> show layer
        }
      } else if (keys.ArrowRight) {
        if (mapGame[player.indexMap + 1] !== 1) {
          player.indexMap += 1;
          player.posX += 30;
          player.transX = "translateX(100%)";
          // obj.pacman_mouth.style.transform = "translateX(100%)";
        }
      } else if (keys.ArrowUp) {
        // get inde - when event
        if (mapGame[player.indexMap - 28] !== 1) {
          player.indexMap -= 28;
          player.posY -= 30;
        }
      } else if (keys.ArrowDown) {
        if (
          mapGame[player.indexMap + 28] !== 1 &&
          mapGame[player.indexMap + 28] !== 6
        ) {
          player.indexMap += 28;
          player.posY += 30;
        }
      }

      if (mapGame[player.indexMap] !== 1) {
        if (mapGame[player.indexMap] === 0 || mapGame[player.indexMap] === 4) {
          if (mapGame[player.indexMap] === 0) {
            player.score += 10;
            player.countCoin++;
          }
          if (mapGame[player.indexMap] === 4) {
            player.score += 50;
            player.canKill = true;
            // player.killTime += lastTime
            clearTimeout(killTimer);
            killGhost(player.killTime);
            player.countCoin++;
          }
          mapGame[player.indexMap] = 9;

          if (mapGame[player.indexMap] === 8) {
            if (keys.ArrowLeft) {
              player.posX += 840;
            } else if (keys.ArrowRight) {
              player.posX -= 840;
            }
          }
          //reload game
          if (player.countCoin === 244 && player.life > 0) {
            // console.log(" next try");
            restart("tryAgain");
            window.cancelAnimationFrame(player.rafId);
          }
          //win state
          if (player.countCoin === 244 && player.life === 0) {
            // console.log("win");
            endGame();
            window.cancelAnimationFrame(player.rafId);
          }
        }
        if (mapGame[player.indexMap] === 8) {
          if (keys.ArrowLeft) {
            player.posX += 840;
          } else if (keys.ArrowRight) {
            player.posX -= 840;
          }
        }
        //if not !doorEnemy & teleport
        if (
          player.indexMap !== 391 &&
          player.indexMap !== 420 &&
          player.indexMap !== 350 &&
          player.indexMap !== 349
        ) {
          temp[player.indexMap].children[0].style.opacity = 0;
          obj.pacman_mouth.style.transform = player.transX;
          obj.pacman.style.transform = `translate3d(${player.posX}px, ${player.posY}px, 0)`;
        }
        //loop ghsot check || condition ? || func
        //loop
        // arrGhosts.forEach((g) => {
        //   if (g[name].basePos === player.indexMap) {
        //     goHomeGhost(ghosts.redGhost.basePos);
        //   }
        // });

        if (player.indexMap === ghosts.redGhost.basePos && player.canKill) {
          //goHome() ghost
          player.score += 200;
          console.log("go kill ghost, ghost return base");
          goHomeGhost(ghosts.redGhost.basePos);
          //set posX, posY, direction - def
        }
        if (
          player.indexMap === ghosts.redGhost.basePos ||
          (player.indexMap === ghosts.orangeGhost.basePos && !player.canKill)
        ) {
          // console.log("pacman go  base, life-=1");
          goHome();
          player.life--;
        }
      }
      player.cool = 6;
      //speed * 16.7 each 100ms raf  check inside if cond
      //show scoreboard
      props.scoreBoard.children[0].textContent = `Score ${player.score} Lives ${player.life}  Time: ${player.time.min}m:${player.time.sec}s`;
    }
    player.rafId = requestAnimationFrame(step);
  }
};

const createBoard = () => {
  //create each block -> get data from mapGame array
  mapGame.forEach((el, idx) => {
    createBlock(el);
  });

  // get static elems -> add in Obejct, then add array - tags, change values -> render new value
  for (let i = 0; i < props.size; i++) {
    props.x += 30 + "px "; //cell grid height, width count - for grid
  }
  // 31 count height field Map
  for (let i = 0; i < props.h; i++) {
    props.y += 30 + "px "; //cell grid rows count, 31px
  }
  //set grid rows, columns, size - count
  props.grid.style.gridTemplateColumns = props.x;
  props.grid.style.gridTemplateRows = props.y;
  //board localy dom, props.grid -> in DOm browser inserted
};
const createBlock = (type) => {
  let div = document.createElement("div");
  div.classList.add("box");
  //create new div -> add class, append object - props.grid
  if (type === 0) {
    const coin = document.createElement("div");
    coin.classList.add("coin");
    div.append(coin);
  } else if (type === 1) {
    let wall = document.createElement("div");
    wall.classList.add("wall");
    div.append(wall);
  } else if (type === 4) {
    let cookie = document.createElement("div");
    cookie.classList.add("cookie");
    div.append(cookie);
  } else if (type === 6) {
    let door = document.createElement("div");
    door.classList.add("doorEnemy");
    div.append(door);
  } else if (type === 8) {
    let teleport = document.createElement("div");
    teleport.classList.add("teleport");
    div.append(teleport);
  } else if (type === 9) {
    let free = document.createElement("div");
    free.classList.add("free");
    div.append(free);
  }
  div.type = type;
  temp.push(div);
  props.grid.append(div);
};
